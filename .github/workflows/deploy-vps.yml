name: Deploy FuseLink to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-fuselink-vps
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_PASSWORD }}" > ~/.ssh/vps_password
          chmod 600 ~/.ssh/vps_password

      - name: Sync code to VPS
        run: |
          # Instalar sshpass para autentica√ß√£o com senha
          sudo apt-get update && sudo apt-get install -y sshpass rsync

          # Criar diret√≥rio no VPS
          sshpass -f ~/.ssh/vps_password ssh -o StrictHostKeyChecking=no root@72.60.10.112 "mkdir -p /root/fuselink"

          # Verificar estrutura do projeto antes do rsync
          echo "=== Verificando estrutura localmente antes do rsync ==="
          ls -la apps/
          ls -la packages/

          # Sincronizar c√≥digo via rsync
          sshpass -f ~/.ssh/vps_password rsync -avz --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='dist' \
            --exclude='.next' \
            --exclude='*.db' \
            --exclude='*.db-*' \
            --exclude='apps/api/uploads' \
            --exclude='.env' \
            --exclude='.env.local' \
            --exclude='.turbo' \
            -e "ssh -o StrictHostKeyChecking=no" \
            ./ root@72.60.10.112:/root/fuselink/

          # Verificar se c√≥digo foi copiado
          echo "=== Verificando estrutura na VPS ap√≥s rsync ==="
          sshpass -f ~/.ssh/vps_password ssh -o StrictHostKeyChecking=no root@72.60.10.112 "ls -la /root/fuselink/"

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: 72.60.10.112
          username: root
          password: ${{ secrets.VPS_PASSWORD }}
          port: 22
          timeout: 600s
          command_timeout: 600s
          script: |
            set -e

            echo "=== Iniciando Deploy FuseLink ==="

            # Diret√≥rio da aplica√ß√£o
            APP_DIR="/root/fuselink"

            # ===== PROTE√á√ÉO DE VOLUMES - VERIFICA√á√ÉO CR√çTICA =====
            echo "=== Verificando volumes Docker antes de qualquer opera√ß√£o ==="

            # Verificar se volumes de dados existem
            POSTGRES_VOLUME=$(docker volume ls -q | grep "fuselink.*postgres" || echo "")
            UPLOADS_VOLUME=$(docker volume ls -q | grep "fuselink.*uploads" || echo "")

            if [ -n "$POSTGRES_VOLUME" ]; then
              echo "‚úÖ Volume PostgreSQL encontrado: $POSTGRES_VOLUME"
              VOLUME_SIZE=$(docker volume inspect "$POSTGRES_VOLUME" 2>/dev/null | grep Mountpoint || echo "")
              echo "   Localiza√ß√£o: $VOLUME_SIZE"
            else
              echo "‚ÑπÔ∏è Volume PostgreSQL n√£o existe (ser√° criado no primeiro deploy)"
            fi

            if [ -n "$UPLOADS_VOLUME" ]; then
              echo "‚úÖ Volume uploads encontrado: $UPLOADS_VOLUME"
            else
              echo "‚ÑπÔ∏è Volume uploads n√£o existe (ser√° criado no primeiro deploy)"
            fi

            # Parar containers existentes (NUNCA usar -v que remove volumes!)
            echo ""
            echo "=== Parando containers (preservando volumes) ==="
            cd $APP_DIR
            docker-compose down || true

            # Verifica√ß√£o de seguran√ßa: garantir que volumes N√ÉO foram removidos
            echo ""
            echo "=== Verifica√ß√£o de seguran√ßa p√≥s-parada ==="
            POSTGRES_VOLUME_AFTER=$(docker volume ls -q | grep "fuselink.*postgres" || echo "")

            if [ -n "$POSTGRES_VOLUME" ] && [ -z "$POSTGRES_VOLUME_AFTER" ]; then
              echo "‚ùå ERRO CR√çTICO: Volume PostgreSQL foi removido inadvertidamente!"
              echo "Este √© um erro grave que pode causar perda de dados."
              exit 1
            else
              echo "‚úÖ Volumes preservados com sucesso"
            fi

            echo "Verificando c√≥digo sincronizado..."
            ls -la

            # Criar arquivo .env
            echo "Criando arquivo .env..."
            cat > .env << 'EOF'
            # Docker Configuration
            EXTERNAL_PORT=3200

            # Database
            DATABASE_URL=postgresql://fuselink:fuselink_production_2024@postgres:5432/fuselink
            POSTGRES_DB=fuselink
            POSTGRES_USER=fuselink
            POSTGRES_PASSWORD=fuselink_production_2024

            # JWT
            JWT_SECRET=fuselink-production-secret-$(openssl rand -hex 32)
            JWT_EXPIRES_IN=7d

            # API
            API_PORT=3001
            API_URL=http://api:3001

            # Frontend
            NEXT_PUBLIC_API_URL=https://fuselink.com.br/api
            NEXTAUTH_SECRET=fuselink-nextauth-$(openssl rand -hex 32)
            NEXTAUTH_URL=https://fuselink.com.br

            # Node Environment
            NODE_ENV=production

            # File Upload
            MAX_FILE_SIZE=10485760
            UPLOAD_DIR=/app/uploads

            # Rate Limiting
            RATE_LIMIT_WINDOW_MS=900000
            RATE_LIMIT_MAX_REQUESTS=100

            # Analytics
            ANALYTICS_RETENTION_DAYS=28
            ANALYTICS_RETENTION_DAYS_PREMIUM=365

            # CORS
            CORS_ORIGIN=https://fuselink.com.br,https://www.fuselink.com.br
            EOF

            # Adicionar BUILD_TIMESTAMP ao .env
            echo "BUILD_TIMESTAMP=$(date +%s)" >> .env

            # ===== LIMPEZA SEGURA (SEM TOCAR EM VOLUMES) =====
            echo "=== Limpando recursos antigos (containers e imagens apenas) ==="

            # Verificar volumes antes da limpeza
            VOLUMES_BEFORE=$(docker volume ls -q | grep "fuselink" | wc -l)
            echo "üìä Volumes de dados antes da limpeza: $VOLUMES_BEFORE"

            # Limpar APENAS containers parados (NUNCA usar -v que remove volumes)
            echo "Removendo containers parados..."
            docker container prune -f || true

            # Limpar APENAS imagens n√£o utilizadas (volumes n√£o s√£o afetados)
            echo "Removendo imagens n√£o utilizadas..."
            docker image prune -af || true

            # Verificar volumes ap√≥s limpeza
            VOLUMES_AFTER=$(docker volume ls -q | grep "fuselink" | wc -l)
            echo "üìä Volumes de dados ap√≥s limpeza: $VOLUMES_AFTER"

            if [ "$VOLUMES_BEFORE" -ne "$VOLUMES_AFTER" ]; then
              echo "‚ùå ERRO CR√çTICO: Volumes foram removidos durante limpeza!"
              echo "Antes: $VOLUMES_BEFORE | Depois: $VOLUMES_AFTER"
              exit 1
            else
              echo "‚úÖ Limpeza conclu√≠da com seguran√ßa, volumes preservados"
            fi

            # Garantir BUILD_TIMESTAMP como vari√°vel de ambiente
            export BUILD_TIMESTAMP=$(date +%s)
            echo "BUILD_TIMESTAMP=${BUILD_TIMESTAMP}"

            # ===== VALIDA√á√ÉO PR√â-BUILD =====
            echo "=== Validando estrutura do projeto antes do build ==="

            if [ ! -f "apps/api/package.json" ]; then
              echo "‚ùå ERRO: apps/api/package.json n√£o encontrado!"
              exit 1
            fi
            echo "‚úì api/package.json encontrado"

            if [ ! -f "apps/web/package.json" ]; then
              echo "‚ùå ERRO: apps/web/package.json n√£o encontrado!"
              exit 1
            fi
            echo "‚úì web/package.json encontrado"

            if [ ! -d "packages/database" ]; then
              echo "‚ùå ERRO: diret√≥rio packages/database n√£o encontrado!"
              exit 1
            fi
            echo "‚úì Estrutura database encontrada"

            if [ ! -f "packages/database/prisma/schema.prisma" ]; then
              echo "‚ùå ERRO: schema.prisma n√£o encontrado!"
              exit 1
            fi
            echo "‚úì schema.prisma encontrado"

            echo "=== Todos os arquivos cr√≠ticos validados ==="

            # Parar e remover containers antigos
            echo "Parando e removendo containers antigos (preservando volumes)..."
            docker-compose down --remove-orphans || true

            # Remover imagens antigas do FuseLink
            echo "Removendo imagens antigas..."
            docker images | grep fuselink | awk '{print $3}' | xargs docker rmi -f 2>/dev/null || true

            # Build das imagens Docker
            echo "Construindo imagens Docker..."
            docker-compose build --no-cache --pull || { echo "‚ùå Erro ao construir imagens Docker"; exit 1; }
            echo "‚úÖ Imagens Docker constru√≠das com sucesso"

            # Iniciar containers
            echo "Iniciando containers..."
            docker-compose up -d --remove-orphans || { echo "‚ùå Erro ao iniciar containers"; exit 1; }
            echo "‚úÖ Containers iniciados"

            # Aguardar containers iniciarem
            echo "Aguardando containers iniciarem..."
            sleep 20

            # Verificar status dos containers
            echo "=== Verificando status dos containers ==="
            docker-compose ps

            # Verificar se containers est√£o rodando
            if ! docker ps | grep -q fuselink-web; then
              echo "‚ùå Container fuselink-web n√£o est√° rodando!"
              echo "=== Logs do container ==="
              docker logs fuselink-web --tail=100
              exit 1
            fi
            echo "‚úì Container fuselink-web est√° rodando"

            if ! docker ps | grep -q fuselink-api; then
              echo "‚ùå Container fuselink-api n√£o est√° rodando!"
              echo "=== Logs do API ==="
              docker logs fuselink-api --tail=100
              exit 1
            fi
            echo "‚úì Container fuselink-api est√° rodando"

            if ! docker ps | grep -q fuselink-postgres; then
              echo "‚ùå Container fuselink-postgres n√£o est√° rodando!"
              echo "=== Logs do PostgreSQL ==="
              docker logs fuselink-postgres --tail=50
              exit 1
            fi
            echo "‚úì Container fuselink-postgres est√° rodando"

            # Aguardar PostgreSQL estar pronto
            echo "Aguardando PostgreSQL ficar pronto..."
            sleep 10

            # ===== BACKUP AUTOM√ÅTICO ANTES DE MIGRATIONS =====
            echo "=== Criando backup de seguran√ßa antes de migrations ==="
            if docker ps | grep -q fuselink-postgres; then
              # Verificar se banco tem dados
              TABLE_COUNT=$(docker exec fuselink-postgres psql -U fuselink -d fuselink -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE';" 2>/dev/null | tr -d '[:space:]' || echo "0")

              if [ -n "$TABLE_COUNT" ] && [ "$TABLE_COUNT" -gt "0" ] 2>/dev/null; then
                echo "üìä Banco tem $TABLE_COUNT tabela(s), criando backup de seguran√ßa..."

                # Criar diret√≥rio de backups
                mkdir -p ${APP_DIR}/backups

                # Criar backup
                BACKUP_FILE="${APP_DIR}/backups/pre_deploy_$(date +%Y%m%d_%H%M%S).sql"
                docker exec fuselink-postgres pg_dump -U fuselink -d fuselink --clean --if-exists > "$BACKUP_FILE"

                if [ -s "$BACKUP_FILE" ]; then
                  echo "‚úÖ Backup criado: $BACKUP_FILE ($(du -h "$BACKUP_FILE" | cut -f1))"
                  ln -sf "$BACKUP_FILE" "${APP_DIR}/backups/latest.sql"
                else
                  echo "‚ö†Ô∏è AVISO: Backup vazio ou falhou, mas continuando deploy..."
                fi
              else
                echo "‚ÑπÔ∏è Banco vazio, backup n√£o necess√°rio"
              fi
            fi

            # ===== EXECUTAR MIGRATIONS =====
            echo "=== Executando migrations do Prisma ==="

            # Aguardar API estar pronta
            sleep 5

            # Executar migrations via container da API
            if docker exec fuselink-api npx prisma migrate deploy --schema=./packages/database/prisma/schema.prisma; then
              echo "‚úÖ Migrations aplicadas com sucesso"
            else
              echo "‚ùå ERRO: Migrations falharam!"
              echo "üîÑ Tentando restaurar backup..."

              if [ -f "${APP_DIR}/backups/latest.sql" ]; then
                docker exec -i fuselink-postgres psql -U fuselink -d fuselink < "${APP_DIR}/backups/latest.sql"
                echo "‚úÖ Backup restaurado, rollback completo"
              fi

              docker logs fuselink-api --tail=50
              exit 1
            fi

            # Verificar se tabelas foram criadas
            echo "=== Validando cria√ß√£o de tabelas ==="
            TABLE_COUNT=$(docker exec fuselink-postgres psql -U fuselink -d fuselink -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE';" 2>/dev/null | tr -d '[:space:]' || echo "0")

            echo "DEBUG: TABLE_COUNT='$TABLE_COUNT'"

            if [ -n "$TABLE_COUNT" ] && [ "$TABLE_COUNT" -gt "0" ] 2>/dev/null; then
              echo "‚úÖ Validado: $TABLE_COUNT tabela(s) criada(s) no banco"
            else
              echo "‚ùå ERRO: Nenhuma tabela encontrada ap√≥s migrations!"
              echo "=== Listando tabelas ==="
              docker exec fuselink-postgres psql -U fuselink -d fuselink -c "\dt"
              exit 1
            fi

            # Verificar se seed j√° foi executado
            echo "=== Verificando necessidade de executar seed ==="
            USER_COUNT=$(docker exec fuselink-postgres psql -U fuselink -d fuselink -t -c "SELECT COUNT(*) FROM \"User\";" 2>/dev/null | tr -d '[:space:]' || echo "0")

            echo "DEBUG: USER_COUNT='$USER_COUNT'"

            if [ "$USER_COUNT" = "0" ] || [ -z "$USER_COUNT" ]; then
              echo "üì¶ Banco de dados vazio, executando seed..."

              # Executar seed
              if docker exec fuselink-api sh -c "cd packages/database && npx tsx prisma/seed.ts"; then
                echo "‚úÖ Seed executado com sucesso!"

                # Validar que usu√°rio foi criado
                echo "=== Validando cria√ß√£o de usu√°rios ==="
                USER_COUNT_AFTER=$(docker exec fuselink-postgres psql -U fuselink -d fuselink -t -c "SELECT COUNT(*) FROM \"User\";" 2>/dev/null | tr -d '[:space:]' || echo "0")

                if [ -n "$USER_COUNT_AFTER" ] && [ "$USER_COUNT_AFTER" -gt "0" ] 2>/dev/null; then
                  echo "‚úÖ Validado: $USER_COUNT_AFTER usu√°rio(s) criado(s) no banco"

                  # Listar usu√°rios criados
                  echo "=== Usu√°rios criados ==="
                  docker exec fuselink-postgres psql -U fuselink -d fuselink -c "SELECT email, username, name FROM \"User\";"
                else
                  echo "‚ö†Ô∏è AVISO: Nenhum usu√°rio encontrado ap√≥s seed"
                fi
              else
                echo "‚ö†Ô∏è AVISO: Seed falhou, mas continuando (pode ser normal se j√° existem dados)"
              fi
            else
              echo "‚úì Seed j√° foi executado anteriormente ($USER_COUNT usu√°rios existem)"
            fi

            # ===== LOGS DE DIAGN√ìSTICO =====
            echo "=== Logs da API (√∫ltimas 50 linhas) ==="
            docker logs fuselink-api --tail=50

            echo ""
            echo "=== Logs do Frontend (√∫ltimas 30 linhas) ==="
            docker logs fuselink-web --tail=30

            # ===== CONFIGURAR NGINX =====
            echo "=== Configurando Nginx para porta 3200 ==="

            # Criar configura√ß√£o do Nginx
            cat > /etc/nginx/sites-available/fuselink.conf << 'NGINX_EOF'
            # HTTP - FuseLink
            server {
                listen 80;
                listen [::]:80;

                server_name fuselink.com.br www.fuselink.com.br;

                # Redirecionar HTTP para HTTPS
                return 301 https://$server_name$request_uri;
            }

            # HTTPS - FuseLink
            server {
                listen 443 ssl http2;
                listen [::]:443 ssl http2;

                server_name fuselink.com.br www.fuselink.com.br;

                # SSL Configuration (certbot ir√° adicionar certificados)
                # ssl_certificate e ssl_certificate_key ser√£o configurados pelo certbot

                # Logs
                access_log /var/log/nginx/fuselink-access.log;
                error_log /var/log/nginx/fuselink-error.log;

                # Limite de upload (para imagens/v√≠deos)
                client_max_body_size 10M;
                client_body_timeout 300s;

                # Proxy para aplica√ß√£o na porta 3200
                location / {
                    proxy_pass http://127.0.0.1:3200;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection 'upgrade';
                    proxy_set_header Host $host;
                    proxy_cache_bypass $http_upgrade;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;

                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                }

                # Health check
                location /health {
                    proxy_pass http://127.0.0.1:3200/health;
                    access_log off;
                }

                # Uploads
                location /uploads/ {
                    proxy_pass http://127.0.0.1:3200/uploads/;
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                }
            }
            NGINX_EOF

            # Habilitar site
            ln -sf /etc/nginx/sites-available/fuselink.conf /etc/nginx/sites-enabled/

            # Testar e recarregar Nginx
            nginx -t && systemctl reload nginx
            echo "‚úÖ Nginx configurado com sucesso na porta 3200"

            # Aguardar Nginx iniciar
            sleep 3

            # Verificar se est√° escutando nas portas
            echo "=== Verificando portas em uso ==="
            netstat -tulpn | grep nginx | grep ":80 " || echo "‚ö†Ô∏è Nginx n√£o encontrado na porta 80"
            netstat -tulpn | grep nginx | grep ":443 " || echo "‚ö†Ô∏è Nginx n√£o encontrado na porta 443"
            netstat -tulpn | grep -E "docker|nginx" | grep ":3200 " || echo "‚ö†Ô∏è App n√£o encontrado na porta 3200"

            # ===== VERIFICAR HEALTH CHECK =====
            echo "=== Verificando health check ==="
            for i in {1..30}; do
              if curl -f http://localhost:3200/health 2>/dev/null; then
                echo "‚úÖ FuseLink est√° rodando na porta 3200!"

                echo ""
                echo "=== Testando frontend ==="
                curl -I http://localhost:3200 2>/dev/null | head -5

                echo ""
                echo "=== Testando API ==="
                curl -I http://localhost:3200/api/health 2>/dev/null | head -5 || echo "‚ÑπÔ∏è API health endpoint espec√≠fico n√£o dispon√≠vel"

                echo ""
                echo "‚úÖ Deploy conclu√≠do - aplica√ß√£o est√° rodando!"
                echo "üìç URLs:"
                echo "   - https://fuselink.com.br"
                echo "   - https://www.fuselink.com.br"
                echo "üìç Porta externa: 3200"
                echo "üì¶ Volumes persistentes:"
                echo "   - postgres_data: PostgreSQL database"
                echo "   - uploads: Arquivos enviados"

                echo ""
                echo "‚ö†Ô∏è IMPORTANTE: Configure SSL com certbot (se ainda n√£o configurado):"
                echo "   sudo certbot --nginx -d fuselink.com.br -d www.fuselink.com.br"

                exit 0
              fi
              echo "Tentativa $i/30 falhou, aguardando 10s..."

              # Mostrar logs a cada 5 tentativas
              if [ $((i % 5)) -eq 0 ]; then
                echo "=== Logs recentes da API ==="
                docker logs fuselink-api --tail=20
                echo "=== Logs recentes do Web ==="
                docker logs fuselink-web --tail=20
              fi

              sleep 10
            done

            echo "‚ö†Ô∏è Health check falhou ap√≥s 30 tentativas"
            echo "=== Logs completos ==="
            docker-compose logs --tail=100
            exit 1

      - name: Verify Deployment
        if: success()
        run: |
          echo "‚úÖ Deploy do FuseLink conclu√≠do com sucesso!"
          echo "üåê FuseLink dispon√≠vel em:"
          echo "   - https://fuselink.com.br"
          echo "   - https://www.fuselink.com.br"
          echo "üìä Health check: https://fuselink.com.br/health"
          echo "üê≥ Containers rodando:"
          echo "   - fuselink-web (frontend Next.js)"
          echo "   - fuselink-api (backend Express)"
          echo "   - fuselink-postgres (banco de dados)"
          echo "   - fuselink-nginx (reverse proxy)"
          echo ""
          echo "üìù Usu√°rio demo (se seed foi executado):"
          echo "   Email: demo@fuselink.com"
          echo "   Senha: password123"
          echo ""
          echo "‚ö†Ô∏è PR√ìXIMO PASSO (se ainda n√£o configurado):"
          echo "   Execute na VPS para configurar SSL:"
          echo "   sudo certbot --nginx -d fuselink.com.br -d www.fuselink.com.br"
